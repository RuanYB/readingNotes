# Head First Design Pattern reading notes

## Strategy

定义算法族，分别封装，让其之间可以互相替换。令算法的变化独立于使用的客户。

## Observer

在对象之间建立一对多的依赖。当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。

## Decorator

`装饰者模式 —— 动态地将责任附加到对象上`

- 装饰者和被装饰对象有相同的超类型
- 可以用一个或多个装饰者包装对象
- 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为
- 对象可以在任何时候被装饰，所以可以在**运行时**动态地、不限量地装饰对象
- 装饰者模式易引起**小类爆炸**，配合工厂（factory）模式和生成器（builer）模式，能够很好地解决该问题

## Factory

所有的工厂都是用来封装对象的创建。

### 简单工厂

并非严格意义上的模式。其工厂方法常声明为静态：

**静态工厂**不需要使用创建对象的方法来实例化对象；但也不能通过**继承**来改变创建方法的行为。

### 工厂方法

定义了一个创建对象的接口，但由子类决定要实例化的类，将类的实例化推迟到子类。

### 依赖倒置原则

`要依赖抽象，不要依赖具体类。`

- 变量不可以持有具体类的引用；
- 不要让类派生自具体类；
- 不要覆盖基类中已实现的方法；

不管高层或低层组件都应依赖于抽象。工厂方法是实现依赖倒置的方法之一。

### 抽象工厂

提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

`工厂方法暗含于抽象工厂中`

- 抽象工厂的任务是定义一个负责创建**一组产品**的接口；
- 该接口内的每个方法都负责创建一个具体产品，并通过实现抽象工厂的子类来提供具体的做法；
- 创建产品的方法通常以“工厂方法”来实现。

## Singleton
